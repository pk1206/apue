<h1 id=file_notes>
    第10章 信号
</h1>

[章节目录](../../README.md#title_ch10 "返回章节目录")
[函数表](func.md "进入函数表")

---

<h2 id=ch_10.2>
    信号概念
</h2>

* 信号是软中断，提供了一种处理异步事件的方法。
* 每个信号都有一个名字，以SIG开头。
* 信号被定义为一个`正整数`，即信号编号。可通过`kill -l`命令查看。
* 不存在编号为0的信号，POSIX.1将0称为空信号。

产生信号的条件：
* 当用户按某些终端键时，引发终端产生的信号。
> Delete, Ctrl+C, Ctrl+D
* 硬件异常产生信号，除数为0，无效的内存引用等。
* 进程调用kill函数将任意的信号值发送给另一个进程或进程组。
* 进程调用kill命令将信号发送给其他进程。
* 当检测到某种软条件发生时。

信号出现时的处理方式：
* 忽略此信号
> * SIGKILL 和 SIGSTOP不能被忽略。
> * 忽略硬件异常产生的信号，则进程的运行行为是未定义的。
* 捕捉信号，调用一个指定的用户函数。
* 执行系统默认动作。绝大多数信号的默认动作是终止进程。

常用信号及其产生条件：

<table>
    <tr><th>信号</th><th>产生条件</th></tr>
    <tr>
        <td>SIGABRT</td>
        <td>调用abort()函数产生此信号，进程异常终止。</td>
    </tr>
    <tr>
        <td>SIGALRM</td>
        <td>用alarm函数设置的定时器超时时，产生此信号。</td>
    </tr>
    <tr>
        <td>SIGBUS</td>
        <td>指示一个实现定义的硬件故障。</td>
    </tr>
    <tr>
        <td>SIGCHLD</td>
        <td>在一个进程终止或停止时，SIGCHLD信号被送给父进程。<br>
            注意，还有一个类似的信号SIGCLD（无H），具有不同的语义。</td>
    </tr>
    <tr>
        <td>SIGCONT</td>
        <td>此作业控制信号发送给需要继续运行，但当前处于停止状态的进程。</td>
    </tr>
    <tr>
        <td>SIGILL</td>
        <td>进程执行一条硬件非法指令。</td>
    </tr>
    <tr>
        <td>SIGINT</td>
        <td>用户按中断键时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。</td>
    </tr>
    <tr>
        <td>SIGKILL</td>
        <td>不能被捕捉或忽略，向系统管理员提供了一种可以杀死任一进程的可靠方法。</td>
    </tr>
    <tr>
        <td>SIGPIPE</td>
        <td>在管道的读进程已终止时写管道，则产生此信号。</td>
    </tr>
    <tr>
        <td>SIGQUIT</td>
        <td>当用户在终端上按退出键时，终端驱动程序产生此信号并发送给前台进程组中的所有进程。</td>
    </tr>
    <tr>
        <td>SIGSEGV</td>
        <td>进程进行了一次无效的内存引用。sementation violation。</td>
    </tr>
    <tr>
        <td>SIGSTOP</td>
        <td>不能被捕获或忽略。用于停止一个进程。</td>
    </tr>
    <tr>
        <td>SIGSYS</td>
        <td>无效的系统调用。</td>
    </tr>
    <tr>
        <td>SIGTSTP</td>
        <td>交互停止信号。用户在终端上按挂起键时，终端驱动程序产生此信号。</td>
    </tr>
    <tr>
        <td>SIGTTIN</td>
        <td>后台进程组尝试读终端时，终端驱动程序产生此信号。</td>
    </tr>
    <tr>
        <td>SIGTTOU</td>
        <td>后台进程组尝试写终端时，终端驱动程序产生此信号。</td>
    </tr>
</table>

<h2 id=ch_10.3>
    函数signal
</h2>

```c
#include <signal.h>
typedef void Sigfunc(int);
Sigfunc *signal(int signo, Sigfunc *func);
返回值：若成功，返回以前的信号处理方式；出错返回SIG_ERR。
功能：指定信号signo的处理方式func。
形参说明：
    signo：信号名。
    func：
        常量 SIG_IGN：忽略此信号。
        常量 SIG_DFL：系统默认动作。
        信号处理函数的地址：调用该函数
注意：
    signal的语义与实现有关，所以最好使用sigaction函数代替signal。
```

信号处理程序：返回值为void，带一个int类型的形参，其值为当前处理的信号。

signal需要改变信号的处理方式，才能确定型号的当前处理方式。而sigaction没有此限制。

exec调用：
* 将原先设置为要捕捉的信号都更改为默认动作。因为信号捕捉函数的地址在新程序中很可能无效。
fork调用：
* 子进程继承父进程的信号处理方式。因为信号捕捉函数的地址在子进程中是有意义的。

示例代码：<a href="code/test_signal.c">test_signal.c</a>

<h2 id=ch_10.4>
    不可靠信号
</h2>

在早期的UNIX实现中，信号是不可靠的，有以下几个问题：
* 信号可能会丢失。信号发生了，但是进程可能一直不知道。
* 对信号的控制能力很差。只能捕获或忽略信号，不能阻塞信号。
> 阻塞信号：不要忽略该信号，在其发生时记住它，然后在进程做好了准备时再通知它。
* 进程每次接到信号对其进行处理时，随即将该信号动作重置为默认值。
* 在进程不希望某种信号发生时，它不能关闭该信号。进程能做的一切就是忽略该信号。

<h2 id=ch_10.5>
    中断的系统调用
</h2>

如果进程在执行一个`低速系统调用`而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为EINTR。

低速系统调用：可能会使进程永远阻塞的一类系统调用。
包括：
* 如果某类型文件的数据不存在，则读操作可能会使调用者永远阻塞。
* 如果数据不能被相同类型的文件立即接受，则写操作可能会使调用者永远阻塞。
* 在某种条件发生之前打开某些类型文件，可能会发生阻塞。
* pause()函数和wait() 函数。
* 某些ioctl操作。
* 某些进程间通信函数。

注意：读写磁盘的文件可能暂时阻塞调用者，除非发生硬件错误，IO操作总会很快完成。

如果write/read已经处理了部分数据，但此时被中断，有两种不同的语义：
1. 该系统调用失败，并将errno设置为EINTR。
2. 该系统调用成功返回，返回值是已经处理的数据量。

POSIX.1 选择的第2种。

出错处理：必须显式地处理出错返回。比如重启，或者其他什么的。

自动重启的系统调用：ioctl read readv write writev wait waitpid

sigaction可以控制信号的SA_RESTART标志，来决定被此信号中断的系统调用是否自动重启。

而对于signal建立的信号处理程序，是否自动重启，不同的实现不一样。Linux会自动重启。

<h2 id=ch_10.6>
    可重入函数
</h2>

* 重入：函数没有执行完成，由于外部的因素或内部调用，又一次进入该函数执行。
* 可重入：函数被重入后不会产生任何不良后果。

可重入函数的特点：
* 不使用任何（局部）静态或全局的非const变量。
* 不返回任何（局部）静态或全局的非const变量的指针。
* 仅依赖于调用方提供的参数
* 不依赖任何单个资源的锁。
* 不调用任何不可重入的函数。

可重入函数，又被称为`异步信号安全`。

可重入函数列表：见书。

常见不可重入函数：
* getpwnam 
* malloc / free
* 标准IO函数，printf等。
* longjmp siglongjmp

由于每个`线程`只有一个errno，信号处理程序很有可能改变errno。所以应当在信号处理程序的开始保存errno，结束后恢复。

在信号处理程序中调用一个非可重入函数，则其结果是不可预知的。

<h2 id=ch_10.7>
    SIGCLD语义
</h2>

SIGCHLD
* BSD的一个信号，POSIX.1采用此信号。
* 子进程状态改变后产生此信号，父进程需要调用一个wait函数以检测发生了什么。

SIGCLD（无H）
* System V的一个信号
* 如果SIGCLD设置为SIG_IGN，则调用进程的子进程将不产生僵尸进程。
* * 子进程在终止时，其状态将被丢弃。
* * 如果此时调用一个wait函数，则会一直阻塞，直到最后一个子进程终止，wait返回-1。
* * 注意：这与其默认动作（SIG_DFL）“忽略”不同。
* 如果将SIGCLD设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果有，则立即调用SIGCLD处理程序。
* * 在[不可靠信号](#ch_10.4)一节中提到，调用信号处理程序时，会设置为默认动作。
* * 如果在信号处理程序的开头，又一次设置SIGCLD，则可能会造成SIGCLD处理程序调用多次。
* * 解决方法：调用wait函数后，再调用signal设置信号处理程序。

注意：同一个处理程序，使用不同的语义，可能会无法工作。所以务必了解所用系统SIGCHLD的语义。

<h2 id=ch_10.8>
    可靠信号术语和语义
</h2>

* `信号产生`：造成信号的事件发生。
  * 事件可以是硬件异常、软件条件、终端产生的信号、调用kill函数。
* `递送`：信号产生后，内核在进程表中以某种形式设置一个标志。
* `未决`：信号产生和递送之间的时间间隔。
* 进程可以选用`阻塞信号递送`。
  * 如果进程产生了一个阻塞信号，并且该信号的动作是系统默认动作或捕捉，则该进程将信号保持为`未决`状态。
  * 直到解除信号的阻塞，或者对信号的动作改为忽略。
* 内核在递送一个信号的时候，才决定对信号的处理方式。
  * 也就是说，在信号递送之前，可以随意的更改对信号的动作。
* `信号排队`：如果信号在被解除阻塞之前产生多次
  * 只递送一次：不对信号进行排队。
  * 递送多次：对信号进行排队。信号排队属于POSIX.1实时扩展，不是所有系统都支持。
* 多个信号同时递送给一个进程
  * POSIX.1没有规定这些信号的递送顺序。
  * POSIX.1建议，先递送与进程状态有关的信号。

<h2 id=ch_10.9>
    函数kill和raise
</h2>

```c
int kill(pid_t pid, int signo);
头文件：signal.h
功能：将信号发送给进程或进程组。
返回值：成功返回0，出错返回-1。

int raise(int signo);
功能：向进程自身发送信号。

kill(getpid(), signo); 等同于 raise(signo);
```

参数pid的说明如下：
* pid  > 0 : 将信号发送给进程ID为pid的进程。
* pid == 0 : 将信号发送给同一进程组的所有进程，如果有权限的话。
* pid  < 0 : 将信号发送给进程组ID等于|pid|，而且有权限向其发送信号的所有进程。
* pid == -1: 将信号发送给有权限发送的所有进程。
* 注：以上的`所有进程`均不含系统进程集中的进程，记录init进程。

kill(pid, 0);
* 仍执行正常的错误检查，但是不发送信号
* 常被用于检测进程是否存在。
* 如果进程不存在，则返回-1，errno设置为ESRCH。
* 注意，此测试不是原子操作。

调用kill为调用进程发送信号，而且此信号是不被阻塞的：
* 在kill返回之前，某个信号被传送至该进程。
* 这个信号，可能是signo，或者其他某个未决信号。

---

[章节目录](../../README.md#title_ch10 "返回章节目录")
[函数表](func.md "进入函数表")