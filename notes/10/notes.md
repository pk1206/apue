<h1 id=file_notes>
    第10章 信号
</h1>

[章节目录](../../README.md#title_ch10 "返回章节目录")
[函数表](func.md "进入函数表")

---

<h2 id=ch_10.2>
    信号概念
</h2>

* 信号是软中断，提供了一种处理异步事件的方法。
* 每个信号都有一个名字，以SIG开头。
* 信号被定义为一个`正整数`，即信号编号。可通过`kill -l`命令查看。
* 不存在编号为0的信号，POSIX.1将0称为空信号。

产生信号的条件：
* 当用户按某些终端键时，引发终端产生的信号。
> Delete, Ctrl+C, Ctrl+D
* 硬件异常产生信号，除数为0，无效的内存引用等。
* 进程调用kill函数将任意的信号值发送给另一个进程或进程组。
* 进程调用kill命令将信号发送给其他进程。
* 当检测到某种软条件发生时。

信号出现时的处理方式：
* 忽略此信号
> * SIGKILL 和 SIGSTOP不能被忽略。
> * 忽略硬件异常产生的信号，则进程的运行行为是未定义的。
* 捕捉信号，调用一个指定的用户函数。
* 执行系统默认动作。绝大多数信号的默认动作是终止进程。

常用信号及其产生条件：

<table>
    <tr><th>信号</th><th>产生条件</th></tr>
    <tr>
        <td>SIGABRT</td>
        <td>调用abort()函数产生此信号，进程异常终止。</td>
    </tr>
    <tr>
        <td>SIGALRM</td>
        <td>用alarm函数设置的定时器超时时，产生此信号。</td>
    </tr>
    <tr>
        <td>SIGBUS</td>
        <td>指示一个实现定义的硬件故障。</td>
    </tr>
    <tr>
        <td>SIGCHLD</td>
        <td>在一个进程终止或停止时，SIGCHLD信号被送给父进程。<br>
            注意，还有一个类似的信号SIGCLD（无H），具有不同的语义。</td>
    </tr>
    <tr>
        <td>SIGCONT</td>
        <td>此作业控制信号发送给需要继续运行，但当前处于停止状态的进程。</td>
    </tr>
    <tr>
        <td>SIGILL</td>
        <td>进程执行一条硬件非法指令。</td>
    </tr>
    <tr>
        <td>SIGINT</td>
        <td>用户按中断键时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。</td>
    </tr>
    <tr>
        <td>SIGKILL</td>
        <td>不能被捕捉或忽略，向系统管理员提供了一种可以杀死任一进程的可靠方法。</td>
    </tr>
    <tr>
        <td>SIGPIPE</td>
        <td>在管道的读进程已终止时写管道，则产生此信号。</td>
    </tr>
    <tr>
        <td>SIGQUIT</td>
        <td>当用户在终端上按退出键时，终端驱动程序产生此信号并发送给前台进程组中的所有进程。</td>
    </tr>
    <tr>
        <td>SIGSEGV</td>
        <td>进程进行了一次无效的内存引用。sementation violation。</td>
    </tr>
    <tr>
        <td>SIGSTOP</td>
        <td>不能被捕获或忽略。用于停止一个进程。</td>
    </tr>
    <tr>
        <td>SIGSYS</td>
        <td>无效的系统调用。</td>
    </tr>
    <tr>
        <td>SIGTSTP</td>
        <td>交互停止信号。用户在终端上按挂起键时，终端驱动程序产生此信号。</td>
    </tr>
    <tr>
        <td>SIGTTIN</td>
        <td>后台进程组尝试读终端时，终端驱动程序产生此信号。</td>
    </tr>
    <tr>
        <td>SIGTTOU</td>
        <td>后台进程组尝试写终端时，终端驱动程序产生此信号。</td>
    </tr>
</table>

<h2 id=ch_10.3>
    函数signal
</h2>

```c
#include <signal.h>
typedef void Sigfunc(int);
Sigfunc *signal(int signo, Sigfunc *func);
返回值：若成功，返回以前的信号处理方式；出错返回SIG_ERR。
功能：指定信号signo的处理方式func。
形参说明：
    signo：信号名。
    func：
        常量 SIG_IGN：忽略此信号。
        常量 SIG_DFL：系统默认动作。
        信号处理函数的地址：调用该函数
注意：
    signal的语义与实现有关，所以最好使用sigaction函数代替signal。
```

信号处理程序：返回值为void，带一个int类型的形参，其值为当前处理的信号。

signal需要改变信号的处理方式，才能确定型号的当前处理方式。而sigaction没有此限制。

exec调用：
* 将原先设置为要捕捉的信号都更改为默认动作。因为信号捕捉函数的地址在新程序中很可能无效。
fork调用：
* 子进程继承父进程的信号处理方式。因为信号捕捉函数的地址在子进程中是有意义的。

示例代码：<a href="code/test_signal.c">test_signal.c</a>

<h2 id=ch_10.4>
    不可靠信号
</h2>

在早期的UNIX实现中，信号是不可靠的，有以下几个问题：
* 信号可能会丢失。信号发生了，但是进程可能一直不知道。
* 对信号的控制能力很差。只能捕获或忽略信号，不能阻塞信号。
> 阻塞信号：不要忽略该信号，在其发生时记住它，然后在进程做好了准备时再通知它。
* 进程每次接到信号对其进行处理时，随即将该信号动作重置为默认值。
* 在进程不希望某种信号发生时，它不能关闭该信号。进程能做的一切就是忽略该信号。

<h2 id=ch_10.5>
    中断的系统调用
</h2>

如果进程在执行一个`低速系统调用`而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为EINTR。

低速系统调用：可能会使进程永远阻塞的一类系统调用。
包括：
* 如果某类型文件的数据不存在，则读操作可能会使调用者永远阻塞。
* 如果数据不能被相同类型的文件立即接受，则写操作可能会使调用者永远阻塞。
* 在某种条件发生之前打开某些类型文件，可能会发生阻塞。
* pause()函数和wait() 函数。
* 某些ioctl操作。
* 某些进程间通信函数。

注意：读写磁盘的文件可能暂时阻塞调用者，除非发生硬件错误，IO操作总会很快完成。

如果write/read已经处理了部分数据，但此时被中断，有两种不同的语义：
1. 该系统调用失败，并将errno设置为EINTR。
2. 该系统调用成功返回，返回值是已经处理的数据量。

POSIX.1 选择的第2种。

出错处理：必须显式地处理出错返回。比如重启，或者其他什么的。

自动重启的系统调用：ioctl read readv write writev wait waitpid

sigaction可以控制信号的SA_RESTART标志，来决定被此信号中断的系统调用是否自动重启。

而对于signal建立的信号处理程序，是否自动重启，不同的实现不一样。Linux会自动重启。

<h2 id=ch_10.6>
    可重入函数
</h2>

* 重入：函数没有执行完成，由于外部的因素或内部调用，又一次进入该函数执行。
* 可重入：函数被重入后不会产生任何不良后果。

可重入函数的特点：
* 不使用任何（局部）静态或全局的非const变量。
* 不返回任何（局部）静态或全局的非const变量的指针。
* 仅依赖于调用方提供的参数
* 不依赖任何单个资源的锁。
* 不调用任何不可重入的函数。

可重入函数，又被称为`异步信号安全`。

可重入函数列表：见书。

常见不可重入函数：
* getpwnam 
* malloc / free
* 标准IO函数，printf等。
* longjmp siglongjmp

由于每个`线程`只有一个errno，信号处理程序很有可能改变errno。所以应当在信号处理程序的开始保存errno，结束后恢复。

在信号处理程序中调用一个非可重入函数，则其结果是不可预知的。

---

[章节目录](../../README.md#title_ch10 "返回章节目录")
[函数表](func.md "进入函数表")